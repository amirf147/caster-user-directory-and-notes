"""
PyAutoGUI Backend Implementation for Window Management

Provides a concrete implementation of the window backend interface
using pyautogui and pygetwindow libraries.

File Metadata:
- Generated by: Claude Opus 4 (Anthropic AI)
- Generation Date: 2025-07-20

Primary Contributors:
- AI Model: Claude Opus 4
- Human Developer: Amir Farhadi
"""

import time
from typing import List, Tuple, Optional, Any

import pyautogui
import pygetwindow as gw

from window_backend import IWindowBackend  # Import the interface


class PyAutoGUIBackend(IWindowBackend):
    """
    Concrete implementation of IWindowBackend using pyautogui/pygetwindow.
    
    This backend uses the same window manipulation library that Caster
    currently uses, ensuring 100% compatibility with existing behavior.
    """
    
    def __init__(self):
        """Initialize the PyAutoGUI backend."""
        # Ensure pyautogui fail-safe is enabled for safety
        pyautogui.FAILSAFE = True
        # Set a small pause between pyautogui calls for reliability
        pyautogui.PAUSE = 0.01
    
    def get_all_windows(self) -> List[Any]:
        """Get all currently open windows using pygetwindow."""
        return gw.getAllWindows()
    
    def get_window_title(self, window: Any) -> str:
        """Get the title of a specific window."""
        # pygetwindow windows have a .title attribute
        return window.title if hasattr(window, 'title') else str(window)
    
    def focus_window(self, window: Any) -> None:
        """Bring a window to the foreground and give it focus."""
        try:
            window.activate()
        except Exception as e:
            # Some windows (like minimized ones) need to be restored first
            if self.is_window_minimized(window):
                self.restore_window(window)
                time.sleep(0.1)
                window.activate()
            else:
                raise e
    
    def get_window_position(self, window: Any) -> Tuple[int, int, int, int]:
        """Get the position and size of a window."""
        return (window.left, window.top, window.width, window.height)
    
    def move_window(self, window: Any, x: int, y: int) -> None:
        """Move a window to a specific position."""
        window.moveTo(x, y)
    
    def resize_window(self, window: Any, width: int, height: int) -> None:
        """Resize a window to specific dimensions."""
        window.resizeTo(width, height)
    
    def maximize_window(self, window: Any) -> None:
        """Maximize a window."""
        window.maximize()
    
    def minimize_window(self, window: Any) -> None:
        """Minimize a window."""
        window.minimize()
    
    def restore_window(self, window: Any) -> None:
        """Restore a window from minimized or maximized state."""
        window.restore()
    
    def is_window_minimized(self, window: Any) -> bool:
        """Check if a window is minimized."""
        return window.isMinimized if hasattr(window, 'isMinimized') else False
    
    def close_window(self, window: Any) -> None:
        """Close a window."""
        window.close()
    
    def find_window_by_title(self, title: str, exact_match: bool = False) -> Optional[Any]:
        """
        Find a window by its title.
        
        Args:
            title: Title to search for
            exact_match: If True, require exact title match. If False, use substring match.
            
        Returns:
            Window object if found, None otherwise
        """
        windows = self.get_all_windows()
        
        for window in windows:
            window_title = self.get_window_title(window)
            
            if exact_match:
                if window_title == title:
                    return window
            else:
                # Case-insensitive substring match
                if title.lower() in window_title.lower():
                    return window
        
        return None
    
    def wait_for_window(self, title: str, timeout: float = 5.0) -> Optional[Any]:
        """
        Wait for a window with specific title to appear.
        
        Args:
            title: Window title to wait for
            timeout: Maximum time to wait in seconds
            
        Returns:
            Window object if found within timeout, None otherwise
        """
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            window = self.find_window_by_title(title, exact_match=False)
            if window:
                return window
            time.sleep(0.1)  # Check every 100ms
        
        return None
    
    def get_active_window(self) -> Optional[Any]:
        """Get the currently active/focused window."""
        try:
            return gw.getActiveWindow()
        except Exception:
            # Sometimes getActiveWindow can fail if no window has focus
            return None
    
    def take_screenshot(self, window: Any = None) -> Any:
        """
        Take a screenshot of a window or the entire screen.
        
        Args:
            window: Specific window to screenshot. If None, screenshot entire screen.
            
        Returns:
            PIL Image object
        """
        if window is None:
            # Full screen screenshot
            return pyautogui.screenshot()
        else:
            # Window-specific screenshot
            left, top, width, height = self.get_window_position(window)
            return pyautogui.screenshot(region=(left, top, width, height))
    
    # Override the default switch_to_window for pyautogui-specific optimizations
    def switch_to_window(self, window: Any) -> None:
        """
        High-level method to reliably switch to a window.
        
        PyAutoGUI-specific implementation that handles edge cases.
        """
        # Check if window is minimized
        if self.is_window_minimized(window):
            self.restore_window(window)
            time.sleep(0.2)  # Slightly longer pause for restore animation
        
        # Activate the window
        try:
            window.activate()
        except Exception:
            # Fallback: Sometimes activate fails, try clicking on the window
            left, top, width, height = self.get_window_position(window)
            pyautogui.click(left + width // 2, top + 10)
        
        # Brief pause to ensure focus is set
        time.sleep(0.05)


# Factory function for creating backends
def create_window_backend(backend_type: str = "pyautogui") -> IWindowBackend:
    """
    Factory function to create window backend instances.
    
    Args:
        backend_type: Type of backend to create. Currently only "pyautogui" is supported.
        
    Returns:
        IWindowBackend: Concrete backend instance
        
    Raises:
        ValueError: If unknown backend type is requested
    """
    if backend_type.lower() == "pyautogui":
        return PyAutoGUIBackend()
    else:
        raise ValueError(f"Unknown backend type: {backend_type}")
    
    # TODO: Future backends could include:
    # - "win32": Direct Windows API backend
    # - "accessibility": OS accessibility API backend
    # - "mock": Testing backend