"""
Switching Commands Facade

Provides a unified interface for window switching operations.
This facade maintains backward compatibility while preparing for
modular backend implementations.

File Metadata:
- Generated by: Claude Opus 4 (Anthropic AI)
- Generation Date: 2025-07-20

Primary Contributors:
- AI Model: Claude Opus 4
- Human Developer: Amir Farhadi

"""

from typing import Optional, Dict, List, Any
import json
import os

# Import the backend interface and implementation
from window_backend import IWindowBackend
from pyautogui_backend import PyAutoGUIBackend, create_window_backend

import sys

util_dir = os.path.abspath(os.path.join(os.getcwd(), ".."))
sys.path.insert(0, util_dir)

import switch_application as legacy_switch

class SwitchingCommands:
    """
    Facade class for window switching operations.
    
    This class provides a stable API for window switching while allowing
    the underlying implementation to evolve. Currently delegates to
    existing switch_application.py functions for zero breaking changes.
    """
    
    def __init__(self, backend: Optional[IWindowBackend] = None):
        """
        Initialize the switching commands facade.
        
        Args:
            backend: Window backend to use. If None, creates default PyAutoGUIBackend.
        """
        self._backend = backend or create_window_backend("pyautogui")
        
        # Initialize internal state that mirrors existing globals
        # These will eventually replace the globals in switch_application.py
        self._aliases: Dict[str, Dict[str, str]] = {}
        self._alias_file_path = legacy_switch.ALIAS_FILE_PATH if hasattr(legacy_switch, 'ALIAS_FILE_PATH') else "window_aliases.json"
        
        # Load existing aliases
        self._load_aliases()
        
        # Track current window info (will replace global window_info)
        self._current_window_info = None
    
    # === Window Information Management ===
    
    def set_window(self, window_obj: Any) -> None:
        """
        Set the current window object.
        
        Args:
            window_obj: Window object to set as current
            
        Note: Currently delegates to legacy function for compatibility.
        """
        # Delegate to existing function
        legacy_switch.set_window(window_obj)
        
        # Also store locally for future migration
        self._current_window_info = legacy_switch.window_info
    
    def set_page(self, page_name: str) -> None:
        """
        Set the current page/view within the active window.
        
        Args:
            page_name: Name of the page to set
            
        Note: Currently delegates to legacy function for compatibility.
        """
        # Delegate to existing function
        legacy_switch.set_page(page_name)
        
        # Update local copy
        if hasattr(legacy_switch, 'window_info'):
            self._current_window_info = legacy_switch.window_info
    
    def get_current_window_info(self) -> Optional[Any]:
        """
        Get the current window information.
        
        Returns:
            Current WindowInfo object or None
        """
        # For now, return the global from legacy
        return getattr(legacy_switch, 'window_info', None)
    
    # === Window Switching Operations ===
    
    def switch_to(self, window_name: str, page_name: Optional[str] = None) -> bool:
        """
        Switch to a window by name, optionally setting a page.
        
        Args:
            window_name: Name or alias of the window to switch to
            page_name: Optional page within the window
            
        Returns:
            True if switch was successful, False otherwise
            
        Note: Currently delegates to legacy function for compatibility.
        """
        # Delegate to existing function
        result = legacy_switch.switch_to(window_name, page_name)
        
        # Update local state
        if hasattr(legacy_switch, 'window_info'):
            self._current_window_info = legacy_switch.window_info
            
        return result
    
    def switch_to_active(self) -> None:
        """
        Switch to the currently active window and update tracking.
        
        Note: Currently delegates to legacy function for compatibility.
        """
        legacy_switch.switch_to_active()
        
        # Update local state
        if hasattr(legacy_switch, 'window_info'):
            self._current_window_info = legacy_switch.window_info
    
    # === Alias Management ===
    
    def _load_aliases(self) -> None:
        """Load aliases from the JSON file."""
        if os.path.exists(self._alias_file_path):
            try:
                with open(self._alias_file_path, 'r') as f:
                    self._aliases = json.load(f)
            except Exception as e:
                print(f"Error loading aliases: {e}")
                self._aliases = {}
        else:
            self._aliases = {}
    
    def _save_aliases(self) -> None:
        """Save aliases to the JSON file."""
        try:
            with open(self._alias_file_path, 'w') as f:
                json.dump(self._aliases, f, indent=2)
        except Exception as e:
            print(f"Error saving aliases: {e}")
    
    def set_alias(self, alias: str, window_name: str, page_name: Optional[str] = None) -> None:
        """
        Set an alias for a window/page combination.
        
        Args:
            alias: Alias name to create
            window_name: Window name the alias refers to
            page_name: Optional page name
            
        Note: Currently delegates to legacy function for compatibility.
        """
        # Delegate to existing function
        legacy_switch.set_alias(alias, window_name, page_name)
        
        # Also update local copy
        self._load_aliases()
    
    def remove_alias(self, alias: str) -> bool:
        """
        Remove an alias.
        
        Args:
            alias: Alias name to remove
            
        Returns:
            True if alias was removed, False if it didn't exist
            
        Note: Currently delegates to legacy function for compatibility.
        """
        # Delegate to existing function
        result = legacy_switch.remove_alias(alias)
        
        # Update local copy
        self._load_aliases()
        
        return result
    
    def get_aliases(self) -> Dict[str, Dict[str, str]]:
        """
        Get all current aliases.
        
        Returns:
            Dictionary of aliases
        """
        # For now, use the legacy function if it exists
        if hasattr(legacy_switch, 'get_aliases'):
            return legacy_switch.get_aliases()
        else:
            # Fallback to local copy
            return self._aliases.copy()
    
    # === Window Listing Operations ===
    
    def list_windows(self, use_backend: bool = False) -> List[str]:
        """
        List all available windows.
        
        Args:
            use_backend: If True, use new backend. If False, use legacy function.
            
        Returns:
            List of window titles
        """
        if use_backend:
            # Use new backend implementation
            windows = self._backend.get_all_windows()
            return [self._backend.get_window_title(w) for w in windows]
        else:
            # Delegate to existing function
            if hasattr(legacy_switch, 'list_windows'):
                return legacy_switch.list_windows()
            else:
                # Fallback to backend
                return self.list_windows(use_backend=True)
    
    def find_window(self, search_term: str, use_backend: bool = False) -> Optional[Any]:
        """
        Find a window by search term.
        
        Args:
            search_term: Term to search for in window titles
            use_backend: If True, use new backend. If False, use legacy function.
            
        Returns:
            Window object if found, None otherwise
        """
        if use_backend:
            # Use new backend implementation
            return self._backend.find_window_by_title(search_term, exact_match=False)
        else:
            # Delegate to existing function if it exists
            if hasattr(legacy_switch, 'find_window'):
                return legacy_switch.find_window(search_term)
            else:
                # Fallback to backend
                return self.find_window(search_term, use_backend=True)
    
    # === Backend Access ===
    
    def get_backend(self) -> IWindowBackend:
        """
        Get the current window backend.
        
        Returns:
            The current IWindowBackend instance
        """
        return self._backend
    
    def set_backend(self, backend: IWindowBackend) -> None:
        """
        Set a new window backend.
        
        Args:
            backend: New backend to use
        """
        self._backend = backend
    
    # === Migration Helpers ===
    
    def is_using_legacy(self) -> bool:
        """
        Check if still using legacy implementation.
        
        Returns:
            True if delegating to legacy functions
        """
        # Currently always true until migration complete
        return True
    
    # TODO: Future methods for complete migration:
    # - migrate_from_legacy(): Transfer all state from globals
    # - use_new_implementation(): Switch to backend-only mode
    # - deprecation_warnings(): Warn about legacy usage


# === Module-level convenience instance ===
# This allows using the facade similar to the current