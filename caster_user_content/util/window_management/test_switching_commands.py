"""
Test Suite for SwitchingCommands Facade

Tests the facade functionality both with and without legacy code.

File Metadata:
- Generated by: Claude Opus 4 (Anthropic AI)
- Generation Date: 2025-07-20

Primary Contributors:
- AI Model: Claude Opus 4
- Human Developer: Amir Farhadi

"""

import os
import json
import tempfile
from unittest.mock import Mock, patch, MagicMock

from switching_commands import SwitchingCommands
from window_backend import IWindowBackend
from pyautogui_backend import PyAutoGUIBackend


def test_facade_initialization():
    """Test that the facade initializes correctly"""
    print("\n=== Testing Facade Initialization ===")
    
    # Test default initialization
    facade = SwitchingCommands()
    assert facade is not None
    print("✓ Facade created with default backend")
    
    # Test with custom backend
    mock_backend = Mock(spec=IWindowBackend)
    facade_custom = SwitchingCommands(backend=mock_backend)
    assert facade_custom.get_backend() == mock_backend
    print("✓ Facade created with custom backend")
    
    # Test backend is correct type
    assert isinstance(facade.get_backend(), IWindowBackend)
    print("✓ Default backend implements IWindowBackend")


def test_backend_operations():
    """Test backend-related operations"""
    print("\n=== Testing Backend Operations ===")
    
    facade = SwitchingCommands()
    
    # Test getting backend
    backend = facade.get_backend()
    assert isinstance(backend, PyAutoGUIBackend)
    print("✓ get_backend() returns PyAutoGUIBackend")
    
    # Test setting new backend
    mock_backend = Mock(spec=IWindowBackend)
    facade.set_backend(mock_backend)
    assert facade.get_backend() == mock_backend
    print("✓ set_backend() changes backend successfully")


def test_alias_operations():
    """Test alias management with temporary file"""
    print("\n=== Testing Alias Operations ===")
    
    # Create temporary alias file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
        temp_alias_file = f.name
        json.dump({}, f)
    
    try:
        # Mock the legacy module
        mock_legacy = Mock()
        mock_legacy.ALIAS_FILE_PATH = temp_alias_file
        mock_legacy.set_alias = Mock()
        mock_legacy.remove_alias = Mock(return_value=True)
        mock_legacy.get_aliases = Mock(return_value={"test": {"window": "TestWindow"}})
        
        # Patch the import
        with patch('switching_commands.legacy_switch', mock_legacy):
            facade = SwitchingCommands()
            
            # Test loading empty aliases
            assert facade._aliases == {}
            print("✓ Loads empty aliases correctly")
            
            # Test set_alias delegation
            facade.set_alias("myalias", "MyWindow", "MyPage")
            mock_legacy.set_alias.assert_called_once_with("myalias", "MyWindow", "MyPage")
            print("✓ set_alias() delegates to legacy")
            
            # Test remove_alias delegation
            result = facade.remove_alias("myalias")
            assert result == True
            mock_legacy.remove_alias.assert_called_once_with("myalias")
            print("✓ remove_alias() delegates to legacy")
            
            # Test get_aliases
            aliases = facade.get_aliases()
            assert "test" in aliases
            print("✓ get_aliases() returns expected data")
            
    finally:
        # Clean up temp file
        os.unlink(temp_alias_file)


def test_window_operations():
    """Test window switching operations"""
    print("\n=== Testing Window Operations ===")
    
    # Create a temporary file path for aliases
    temp_alias_path = os.path.join(tempfile.gettempdir(), "test_aliases.json")
    
    # Mock the legacy module
    mock_legacy = Mock()
    mock_legacy.ALIAS_FILE_PATH = temp_alias_path  # ← Fixed: Use actual string path
    mock_legacy.window_info = Mock(window_title="Test Window", page="Test Page")
    mock_legacy.set_window = Mock()
    mock_legacy.set_page = Mock()
    mock_legacy.switch_to = Mock(return_value=True)
    mock_legacy.switch_to_active = Mock()
    mock_legacy.list_windows = Mock(return_value=["Window1", "Window2"])
    mock_legacy.find_window = Mock(return_value=Mock())
    
    # Ensure the temp alias file exists
    with open(temp_alias_path, 'w') as f:
        json.dump({}, f)
    
    try:
        with patch('switching_commands.legacy_switch', mock_legacy):
            facade = SwitchingCommands()
            
            # Test set_window
            mock_window = Mock()
            facade.set_window(mock_window)
            mock_legacy.set_window.assert_called_once_with(mock_window)
            print("✓ set_window() delegates correctly")
            
            # Test set_page
            facade.set_page("NewPage")
            mock_legacy.set_page.assert_called_once_with("NewPage")
            print("✓ set_page() delegates correctly")
            
            # Test switch_to
            result = facade.switch_to("MyWindow", "MyPage")
            assert result == True
            mock_legacy.switch_to.assert_called_once_with("MyWindow", "MyPage")
            print("✓ switch_to() delegates correctly and returns result")
            
            # Test switch_to_active
            facade.switch_to_active()
            mock_legacy.switch_to_active.assert_called_once()
            print("✓ switch_to_active() delegates correctly")
            
            # Test list_windows (legacy mode)
            windows = facade.list_windows(use_backend=False)
            assert windows == ["Window1", "Window2"]
            print("✓ list_windows() delegates to legacy")
            
            # Test find_window (legacy mode)
            found = facade.find_window("test", use_backend=False)
            assert found is not None
            mock_legacy.find_window.assert_called_once_with("test")
            print("✓ find_window() delegates to legacy")
            
    finally:
        # Clean up temp file
        if os.path.exists(temp_alias_path):
            os.unlink(temp_alias_path)

def test_backend_window_listing():
    """Test window operations using backend directly"""
    print("\n=== Testing Backend Window Operations ===")
    
    # Create facade with mock backend
    mock_backend = Mock(spec=IWindowBackend)
    mock_backend.get_all_windows = Mock(return_value=[
        Mock(title="Window A"),
        Mock(title="Window B")
    ])
    mock_backend.get_window_title = Mock(side_effect=lambda w: w.title)
    mock_backend.find_window_by_title = Mock(return_value=Mock(title="Found Window"))
    
    facade = SwitchingCommands(backend=mock_backend)
    
    # Test list_windows with backend
    windows = facade.list_windows(use_backend=True)
    assert windows == ["Window A", "Window B"]
    print("✓ list_windows() uses backend when requested")
    
    # Test find_window with backend
    found = facade.find_window("test", use_backend=True)
    assert found is not None
    mock_backend.find_window_by_title.assert_called_once_with("test", exact_match=False)
    print("✓ find_window() uses backend when requested")


def test_fallback_behavior():
    """Test fallback when legacy functions don't exist"""
    print("\n=== Testing Fallback Behavior ===")
    
    # Create temp alias file
    temp_alias_path = os.path.join(tempfile.gettempdir(), "test_fallback_aliases.json")
    
    # Mock legacy module with missing functions
    mock_legacy = Mock()
    mock_legacy.ALIAS_FILE_PATH = temp_alias_path
    
    # Configure mock to explicitly NOT have these attributes
    # This is the key fix - tell Mock that these attributes don't exist
    del mock_legacy.list_windows
    del mock_legacy.find_window
    
    # Ensure temp file exists
    with open(temp_alias_path, 'w') as f:
        json.dump({}, f)
    
    try:
        mock_backend = Mock(spec=IWindowBackend)
        mock_backend.get_all_windows = Mock(return_value=[])
        mock_backend.get_window_title = Mock(return_value="Mock Window")
        mock_backend.find_window_by_title = Mock(return_value=None)
        
        with patch('switching_commands.legacy_switch', mock_legacy):
            facade = SwitchingCommands(backend=mock_backend)
            
            # Should fallback to backend
            windows = facade.list_windows(use_backend=False)
            mock_backend.get_all_windows.assert_called()
            print("✓ list_windows() falls back to backend when legacy missing")
            
            # Should fallback to backend
            found = facade.find_window("test", use_backend=False)
            mock_backend.find_window_by_title.assert_called()
            print("✓ find_window() falls back to backend when legacy missing")
            
    finally:
        # Clean up
        if os.path.exists(temp_alias_path):
            os.unlink(temp_alias_path)


def test_state_tracking():
    """Test that facade tracks state correctly"""
    print("\n=== Testing State Tracking ===")
    
    # Create temp alias file
    temp_alias_path = os.path.join(tempfile.gettempdir(), "test_state_aliases.json")
    
    # Create mock legacy module
    mock_legacy = Mock()
    mock_legacy.ALIAS_FILE_PATH = temp_alias_path  # ← Fixed: Use actual string path
    mock_legacy.window_info = Mock(window_title="Initial", page="Page1")
    
    # Ensure temp file exists
    with open(temp_alias_path, 'w') as f:
        json.dump({}, f)
    
    try:
        with patch('switching_commands.legacy_switch', mock_legacy):
            facade = SwitchingCommands()
            
            # Test is_using_legacy
            assert facade.is_using_legacy() == True
            print("✓ is_using_legacy() returns True")
            
            # Test current window info
            info = facade.get_current_window_info()
            assert info is not None
            print("✓ get_current_window_info() returns legacy window_info")
            
    finally:
        # Clean up
        if os.path.exists(temp_alias_path):
            os.unlink(temp_alias_path)


def run_all_tests():
    """Run all tests and report results"""
    print("🧪 Running SwitchingCommands Facade Tests")
    print("=" * 50)
    
    try:
        test_facade_initialization()
        test_backend_operations()
        test_alias_operations()
        test_window_operations()
        test_backend_window_listing()
        test_fallback_behavior()
        test_state_tracking()
        
        print("\n" + "=" * 50)
        print("✅ ALL TESTS PASSED! 🎉")
        print("\nThe SwitchingCommands facade is working correctly!")
        print("- Delegates to legacy functions when available")
        print("- Falls back to backend when needed")
        print("- Maintains state tracking")
        print("- Ready for gradual migration")
        
    except AssertionError as e:
        print(f"\n❌ TEST FAILED: {e}")
        raise
    except Exception as e:
        print(f"\n❌ UNEXPECTED ERROR: {e}")
        raise


if __name__ == "__main__":
    run_all_tests()